// convex/orders.ts (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";

// –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –∑–∞–∫–∞–∑
export const create = mutation({
  args: {
    userId: v.optional(v.string()),
    memberId: v.optional(v.string()),
    items: v.array(v.object({
      productId: v.union(v.id("products"), v.string()),
      productName: v.string(),
      quantity: v.number(),
      price: v.number(),
      totalPrice: v.number(),
    })),
    totalAmount: v.number(),
    pickupType: v.string(),
    notes: v.optional(v.string()),
    paymentIntentId: v.optional(v.string()),
    paymentMethod: v.optional(v.string()),
    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ –ø–æ–ª—è
    estimatedReadyTime: v.optional(v.number()),
    orderTime: v.optional(v.number()),
    status: v.optional(v.union(
      v.literal("pending"),
      v.literal("confirmed"),
      v.literal("processing"),
      v.literal("ready"),
      v.literal("completed"),
      v.literal("cancelled")
    )),
    paymentStatus: v.optional(v.union(
      v.literal("pending"),
      v.literal("paid"),
      v.literal("failed"),
      v.literal("refunded")
    )),
  },
  handler: async (ctx, args) => {
    console.log('üîß Convex orders:create –≤—ã–∑–≤–∞–Ω —Å –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏:', args);
    
    try {
      const orderId = await ctx.db.insert("orders", {
        userId: args.userId,
        memberId: args.memberId,
        items: args.items,
        totalAmount: args.totalAmount,
        pickupType: args.pickupType,
        notes: args.notes,
        status: args.status || "pending",
        paymentStatus: args.paymentStatus || "pending",
        paymentIntentId: args.paymentIntentId,
        paymentMethod: args.paymentMethod || 'stripe',
        orderTime: args.orderTime || Date.now(),
        estimatedReadyTime: args.estimatedReadyTime,
      });
      
      console.log('‚úÖ –ó–∞–∫–∞–∑ —Å–æ–∑–¥–∞–Ω –≤ –ë–î —Å ID:', orderId);
      return orderId;
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–∫–∞–∑–∞ –≤ –ë–î:', error);
      throw error;
    }
  },
});

// –ü–æ–ª—É—á–∏—Ç—å –∑–∞–∫–∞–∑ –ø–æ ID
export const get = query({
  args: { id: v.id("orders") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.id);
  },
});

// –ü–æ–ª—É—á–∏—Ç—å –∑–∞–∫–∞–∑—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
export const getUserOrders = query({
  args: { userId: v.string() },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("orders")
      .filter((q) => q.eq(q.field("userId"), args.userId))
      .order("desc")
      .collect();
  },
});

// –ü–æ–ª—É—á–∏—Ç—å –∑–∞–∫–∞–∑—ã —É—á–∞—Å—Ç–Ω–∏–∫–∞
export const getMemberOrders = query({
  args: { memberId: v.string() },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("orders")
      .filter((q) => q.eq(q.field("memberId"), args.memberId))
      .order("desc")
      .collect();
  },
});

// –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞
export const updateStatus = mutation({
  args: {
    id: v.id("orders"),
    status: v.union(
      v.literal("pending"),
      v.literal("confirmed"),
      v.literal("processing"),
      v.literal("ready"),
      v.literal("completed"),
      v.literal("cancelled")
    ),
    estimatedReadyTime: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    console.log('üîÑ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–∫–∞–∑–∞:', args.id, '–Ω–∞', args.status);
    
    const updateData: any = {
      status: args.status,
    };
    
    if (args.estimatedReadyTime) {
      updateData.estimatedReadyTime = args.estimatedReadyTime;
    }
    
    if (args.status === 'completed') {
      updateData.completedTime = Date.now();
    }
    
    await ctx.db.patch(args.id, updateData);
    console.log('‚úÖ –°—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞ –æ–±–Ω–æ–≤–ª–µ–Ω');
    return args.id;
  },
});

// –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å –ø–ª–∞—Ç–µ–∂–∞
export const updatePaymentStatus = mutation({
  args: {
    id: v.id("orders"),
    paymentStatus: v.union(
      v.literal("pending"),
      v.literal("paid"),
      v.literal("failed"),
      v.literal("refunded")
    ),
    paymentId: v.optional(v.string()),
    paidAt: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    console.log('üí≥ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –ø–ª–∞—Ç–µ–∂–∞:', args.id, '–Ω–∞', args.paymentStatus);
    
    const { id, ...updates } = args;
    await ctx.db.patch(id, updates);
    
    console.log('‚úÖ –°—Ç–∞—Ç—É—Å –ø–ª–∞—Ç–µ–∂–∞ –æ–±–Ω–æ–≤–ª–µ–Ω');
    return id;
  },
});

// –ù–∞–π—Ç–∏ –∑–∞–∫–∞–∑ –ø–æ Payment Intent ID
export const getByPaymentIntentId = query({
  args: { paymentIntentId: v.string() },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("orders")
      .filter((q) => q.eq(q.field("paymentIntentId"), args.paymentIntentId))
      .first();
  },
});

// –û–±–Ω–æ–≤–∏—Ç—å –∑–∞–∫–∞–∑ –ø–æ Payment Intent ID
export const updateByPaymentIntentId = mutation({
  args: {
    paymentIntentId: v.string(),
    status: v.optional(v.union(
      v.literal("pending"),
      v.literal("confirmed"),
      v.literal("processing"),
      v.literal("ready"),
      v.literal("completed"),
      v.literal("cancelled")
    )),
    paymentStatus: v.optional(v.union(
      v.literal("pending"),
      v.literal("paid"),
      v.literal("failed"),
      v.literal("refunded")
    )),
    paymentId: v.optional(v.string()),
    paidAt: v.optional(v.number()),
    estimatedReadyTime: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    console.log('üîç –ü–æ–∏—Å–∫ –∑–∞–∫–∞–∑–∞ –ø–æ paymentIntentId:', args.paymentIntentId);
    
    const order = await ctx.db
      .query("orders")
      .filter((q) => q.eq(q.field("paymentIntentId"), args.paymentIntentId))
      .first();
    
    if (!order) {
      console.error('‚ùå –ó–∞–∫–∞–∑ –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ paymentIntentId:', args.paymentIntentId);
      throw new Error("–ó–∞–∫–∞–∑ –Ω–µ –Ω–∞–π–¥–µ–Ω");
    }
    
    console.log('üì¶ –ù–∞–π–¥–µ–Ω –∑–∞–∫–∞–∑:', order._id);
    
    const updateData: any = {};
    
    if (args.status) {
      updateData.status = args.status;
    }
    
    if (args.paymentStatus) {
      updateData.paymentStatus = args.paymentStatus;
    }
    
    if (args.paymentId) {
      updateData.paymentId = args.paymentId;
    }
    
    if (args.paidAt) {
      updateData.paidAt = args.paidAt;
    }
    
    if (args.estimatedReadyTime) {
      updateData.estimatedReadyTime = args.estimatedReadyTime;
    }
    
    if (args.status === 'completed') {
      updateData.completedTime = Date.now();
    }
    
    await ctx.db.patch(order._id, updateData);
    console.log('‚úÖ –ó–∞–∫–∞–∑ –æ–±–Ω–æ–≤–ª–µ–Ω –ø–æ paymentIntentId');
    
    return order._id;
  },
});

// –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∑–∞–∫–∞–∑—ã (–¥–ª—è –∞–¥–º–∏–Ω–∫–∏)
export const list = query({
  args: {},
  handler: async (ctx) => {
    return await ctx.db.query("orders").order("desc").collect();
  },
});

// –ü–æ–ª—É—á–∏—Ç—å –∑–∞–∫–∞–∑—ã –ø–æ —Å—Ç–∞—Ç—É—Å—É
export const getByStatus = query({
  args: { 
    status: v.union(
      v.literal("pending"),
      v.literal("confirmed"),
      v.literal("processing"),
      v.literal("ready"),
      v.literal("completed"),
      v.literal("cancelled")
    )
  },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("orders")
      .filter((q) => q.eq(q.field("status"), args.status))
      .order("desc")
      .collect();
  },
});

// –ü–æ–ª—É—á–∏—Ç—å –∑–∞–∫–∞–∑—ã –ø–æ —Å—Ç–∞—Ç—É—Å—É –ø–ª–∞—Ç–µ–∂–∞
export const getByPaymentStatus = query({
  args: { 
    paymentStatus: v.union(
      v.literal("pending"),
      v.literal("paid"),
      v.literal("failed"),
      v.literal("refunded")
    )
  },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("orders")
      .filter((q) => q.eq(q.field("paymentStatus"), args.paymentStatus))
      .order("desc")
      .collect();
  },
});

// –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∑–∞–∫–∞–∑–æ–≤
export const getStats = query({
  args: {},
  handler: async (ctx) => {
    const allOrders = await ctx.db.query("orders").collect();
    
    const stats = {
      total: allOrders.length,
      pending: allOrders.filter(o => o.status === 'pending').length,
      confirmed: allOrders.filter(o => o.status === 'confirmed').length,
      processing: allOrders.filter(o => o.status === 'processing').length,
      ready: allOrders.filter(o => o.status === 'ready').length,
      completed: allOrders.filter(o => o.status === 'completed').length,
      cancelled: allOrders.filter(o => o.status === 'cancelled').length,
      totalRevenue: allOrders
        .filter(o => o.paymentStatus === 'paid')
        .reduce((sum, o) => sum + o.totalAmount, 0),
      averageOrderValue: allOrders.length > 0 
        ? allOrders.reduce((sum, o) => sum + o.totalAmount, 0) / allOrders.length 
        : 0,
    };
    
    return stats;
  },
});

// –£–¥–∞–ª–∏—Ç—å –∑–∞–∫–∞–∑ (–º—è–≥–∫–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ)
export const remove = mutation({
  args: { id: v.id("orders") },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.id, { 
      status: "cancelled",
      completedTime: Date.now()
    });
    return args.id;
  },
});

// –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤—Ä–µ–º—è –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –∑–∞–∫–∞–∑–∞
export const setEstimatedReadyTime = mutation({
  args: {
    id: v.id("orders"),
    estimatedReadyTime: v.number(),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.id, {
      estimatedReadyTime: args.estimatedReadyTime,
    });
    return args.id;
  },
});

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –ø—Ä–æ–±–ª–µ–º–Ω—ã—Ö –∑–∞–∫–∞–∑–æ–≤
export const cleanupInvalidOrders = mutation({
  args: {},
  handler: async (ctx) => {
    console.log('üßπ –û—á–∏—Å—Ç–∫–∞ –Ω–µ–≤–∞–ª–∏–¥–Ω—ã—Ö –∑–∞–∫–∞–∑–æ–≤...');
    
    const orders = await ctx.db.query("orders").collect();
    let deletedCount = 0;
    
    for (const order of orders) {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –ø—Ä–æ–±–ª–µ–º—ã —Å productId
      const hasInvalidProductIds = order.items?.some(item => 
        typeof item.productId === 'string' && 
        !item.productId.startsWith('k') && 
        item.productId.length < 10
      );
      
      if (hasInvalidProductIds) {
        await ctx.db.delete(order._id);
        deletedCount++;
        console.log('üóëÔ∏è –£–¥–∞–ª–µ–Ω –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–π –∑–∞–∫–∞–∑:', order._id);
      }
    }
    
    console.log(`‚úÖ –£–¥–∞–ª–µ–Ω–æ –Ω–µ–≤–∞–ª–∏–¥–Ω—ã—Ö –∑–∞–∫–∞–∑–æ–≤: ${deletedCount}`);
    return deletedCount;
  },
});
